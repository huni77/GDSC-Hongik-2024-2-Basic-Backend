# 레포지토리 계층

DB와 소통하며 데이터를 조작하는 계층
서비스 계층이 결정한 비즈니스 로직을 실제 DB에 적용한다.

# 데이터 조작: CRUD

• 생성 (Create)
• 조회 (Read)
• 수정 (Update)
• 삭제 (Delete)

CRUD 기능은 JPA가 제공하는 기능을 이용하여 구현한다.

# 엔티티 매니저

우리 대신 DB와 직접 소통하는 객체이다.
JPA는 `application.yml` 정보를 통해 `Entity Manager` 를 생성한다.

## 엔티티 매니저가 하는 일

• 새로 생성한 엔티티 객체를 DB에 추가
• DB에서 조회한 데이터로 엔티티 객체 만들기
• 엔티티 객체에 대한 수정, 삭제를 DB에 반영하기

# 트랜잭션

일련의 동작 과정들을 하나의 단위로 묶어서 동작하도록 하는 것. (Atomic)

JPA는 DB와 유사하게 트랜잭션 단위로 동작한다.
트랜잭션이 끝나면 모든 변경사항을 DB에 반영한다.

트랜잭션 중간에 에러가 발생하면
트랜잭션 범위 안의 모든 변경점을 되돌린다. (롤백)

# 영속성 컨텍스트

DB에서 조회한 엔티티를 `캐싱` 하는 공간
JPA가 DB에 반영할, 엔티티의 모든 변경 사항을 보관하는 공간(일종의 버퍼라고 생각하면 됨)

엔티티에 대한 변경 사항을 영속성 컨텍스트에 저장해 두었다가,
트랜잭션을 커밋하면 저장된 모든 변경점이 DB에 반영되도록 영속성 컨텍스트를 기반으로 한번에 SQL을 생성한다.

## 엔티티 저장 시

1. 엔티티 생성(비영속 상태)

2. `em.persist()` 메소드로 영속성 컨텍스트에 생성한 엔티티를 등록함(영속화)

3. 트랜잭션 커밋 또는 flush 호출 시(`em.flush()`) 한꺼번에 쿼리 진행(쓰기 지연 : 모든 변경사항들을 모아놨다가 한번에 실행)

## 엔티티 조회 시

1. `em.find()` 메소드를 사용해서 DB 에서 엔티티를 가져와서(쿼리) 영속성 컨텍스트에 저장

2. 영속성 컨텍스트에 저장된 엔티티를 JAVA APP으로 가져옴

만약 이전에 조회했던 엔티티를 다시 조회 할 시에는 DB에 쿼리를 보내지 않고 영속성 컨텍스트에 캐싱된 걸 가져온다.

## 엔티티 수정 시

1. `em.find()` 메소드로 수정할 데이터를 DB에서 가져와서 영속성 컨텍스트에 저장

2. 우리가 컨텍스트 안에 있는 객체를 수정 시 수정된 정보와 최초 상태를 비교해서 엔티티 매니저가 자동으로 수정하는 SQL 생성(변경 감지)

3. 트랜잭션 커밋 또는 flush 호출 시(`em.flush()`) 한꺼번에 쿼리 진행

## 엔티티 삭제 시

1. `em.find()` 메소드로 수정할 데이터를 DB에 가져와서 영속성 컨텍스트에 저장

2. 우리가 컨텍스트 안에 있는 객체를 삭제 시 엔티티 매니저가 객체를 삭제 상태로 만든다.

3 .트랜잭션 커밋 또는 flush 호출 시(`em.flush()`) 한꺼번에 쿼리 진행

## 영속성 컨텍스트 정리

엔티티 매니저는 변경 사항을 모았다가, 한번에 SQL을 생성한다.
이때 모든 변경 사항은 영속성 컨텍스트에 저장된다.

엔티티 매니저에게 데이터 변경을 요청하고 싶다면
하나의 데이터를 나타내는 ‘엔티티 객체’를 영속성 컨텍스트에 올려두고
영속성 컨텍스트에 올려둔 엔티티 객체를 변경하면 된다.
